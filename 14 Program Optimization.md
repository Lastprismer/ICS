# Program Optimization

优化是万恶之源！



[TOC]



## 综述

程序的优化：编译器、机器结构

编译器：为机器提供高效的程序图像：寄存器、代码选择和排序





## 通常很有效的优化

**Code Motion**：计算结果相同时，降低计算的次数。例：将相同的运算移出循环，杜绝再次求值

**Reduction in Strength**：通过移位或加法来实现操作数为常数的乘法或除法

**Share Common Subexpressions**：提出相同的计算，减少运算次数



## 优化的限制

编译器优化的原则：

1. 不能改变程序的行为

2. 极端情况下不优化

   优化范围：“基本块Basic Block”，函数内

3. 无法优化算法

4. 一般情况下，*不优化*：只会进行安全的优化
5. 局限性：基于静态信息，难理解程序运行过程，只做确定的优化



### 过程调用

例：

```c
void lower(char *s)
{
    size_t i;
    for (i = 0; i < strlen(s); i++)
        if (s[i] >= 'A' && s[i] <= 'Z')
            s[i] -= ('A' - 'a');
}

```

编译器不会把`strlen(s)`移动到循环外：不知道`strlen`函数是否有副作用（静态？全局改变？），方法：`inline`

### 存储器别名使用

例：

```c
void func1 (int *xp, int *yp)
{
     *xp += *yp;
     *xp += *yp;
}
void func2 (int *xp, int *yp)
{
     *xp += *yp * 2;
}
```

编译器不会把`func1`优化成`func2`：如果`xp == yp`，`func1`结果为`*yp *= 4`，`func2`结果为`*yp *= 3`，不同





## 指令级并行

现代处理器：可以同时运行多条指令

**CPE**：表示程序在向量或列表上运行的性能，每元素周期数（Cycle Per Element）——处理每个元素占用的时钟周期，$T=CPE \times N + overhead$

现代处理器：超标量

<img src="./Images/14-Superscalar Processor.png" style="zoom:67%;" />

超标量处理器能够在一个周期内执行多条指令，实现指令级并行

* *指令控制单元*ICU和*执行单元*EU，ICU从高速缓存中读取指令，把操作发送到EU；*分支预测技术*、*投机执行技术*
* *指令译码*将指令转化成一组基本操作，每个操作都完成简单的计算任务，x86一条指令可以译码成多个操作
* EU接受来自取值单元的操作，通常每个时钟周期会接收多个操作，这些操作会被分派到一组*功能单元*中
* 读写内存：加载和存储单元



### 功能单元的性能

* *延迟*：实际运算所需的时钟周期总数

* *发射时间*：两次运算之间间隔的最小周期数

* *容量*：同时能发射多少个这样的操作

  <img src="./Images/14-Haswell CPU Performance.png" style="zoom:50%;" />

* 很短的发射时间：一系列阶段的流水线实现

* 发射时间为1的功能单元：*完全流水线化的*

CPE的两个基本界限：

* **延迟界限**：必须按照严格顺序完成合并运算的函数所需要的最小CPE值

* **吞吐量界限**：CPE的最小界限

  <img src="./Images/14-CPE Bounds.png" style="zoom:50%;" />

  例：只有一个整数乘法器，发射时间为1个时钟周期，处理器不能支持每个时钟周期大于一条乘法；多个功能单元都可以执行整数加法，有两个加载单元，故为0.5



### 循环展开

* 减少了不直接的操作，如循环索引计算和条件分支；
* **k$\times$1循环展开** ：减少循环开销操作；编译器可以执行循环展开，比如`gcc`开`-O3`
* **k$\times$k循环展开**：使用多个累计变量，多路展开，打破延迟界限（并行）
  * $k \geqslant C \times L$（容量为C，延迟为L）时，程序才能达到吞吐量界限
* **重新结合变换**：$k \times 1a$ 循环展开，改变向量元素和累积值的合并顺序，编译后减少关键路径上的操作次数（另一种挤气泡）
* 展开过深：寄存器溢出，效果反而不好



用向量指令达到更高的并行度：打破吞吐量界限，但是太复杂了





### 分支预测与预测错误处罚

* **投机执行**：直接执行预测分支目标处的指令，但是避免修改任何实际的寄存器或内存位置；如果预测错了，直接丢掉；预测对了，提交结果
* 对付预测错误处罚的处理原则：不要过分关心可预测的分支（现在已经有超过95%的预测成功率），书写适合用条件传送实现的代码