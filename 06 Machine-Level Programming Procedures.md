# Machine-Level Programming III Procedures

**过程**是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

过程包括**函数**（function）、**方法**（method）、**子例程**（subroutine）、**处理函数**（handler）等。



## 机制

假设过程P调用过程Q，Q执行后赶回P。

过程包含的机制：

* **传递控制**：进入过程时，程序计数器必须被设置为Q的代码的起始地址；返回时，程序计数器设置为P中调用Q后代码的地址
* **传递数据**：P能够向Q提供一个或多个参数，Q必须向P返回一个值
* **分配和释放内存**：Q开始时为局部变量分配空间，返回前释放空间

名为ABI（Application Binary Interface，应用程序二进制接口），为特殊的规则。



## 运行时栈

* Region of memory managed with stack discipline 以栈的形式管理内存
* Grows toward lower addresses 栈底在上，栈顶在下，向下生长（上、下为内存中地址的大、小）
* `%rsp`寄存器存储栈最低的地址（栈顶元素的地址）

两个指令：

1. `pushq Src`：等价于：

   `subq $8, %rsp`

   `movq S, (%rsp)`

2. ``pop D`等价于两条指令：

   `movq (%rsp) D`

   `addq $8 %rsp`

* 过程的 **栈帧**：储存过程的返回地址和参数、临时变量（非静态局部变量、编译器自动生成的其他临时变量）、调用的上下文（的地址）



## 过程调用

### 一、过程控制流：过程传送

* 用栈来支持过程的调用和返回
* **过程调用**：`call label`
  * 将**返回地址**压栈
  * 跳到`label`
  * **返回地址**：call 之后的第一个指令的地址
* **过程返回**：`ret`
  * 从栈中弹出地址（刚刚压入栈的返回地址）
  * 跳到那个地址
* **程序计数器**：`%rip`，通过改变`%rip`中地址控制转移



### 二、过程数据流：数据传送

* 寄存器存储前6个参数：`%rdi, %rsi, %rdx, %rcx, %r8, %r9`
* 返回值：`%rax`
* 更多的参数压入栈中，压栈顺序为：参数序号由大到小压栈，即：最后一个参数`Arg n`最先压入栈，`Arg 7`最后压入栈。
  * 只有需要时才会在栈中分配内存（因编译器而异）



### 三、管理临时变量：栈上的局部存储

局部数据需要存储在内存中的情况：

* 寄存器不够存放所有的本地数据
* 对某个局部变量使用地址运算符&，因此必须能够为它产生一个地址
* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到
* 调用函数参数太多



#### 寄存器中的局部存储空间

最终目的：保证调用者的寄存器值不会被被调用者覆盖

函数A调用了函数B，寄存器%rbx在函数B中被修改了，逻辑上%rbx内容在调用函数B的前后应该保持一致，此时应该：

1. 在函数A在调用函数B之前提前保存寄存器%rbx的内容，执行完函数B之后再恢复%rbx的内容，这个策略就称为**调用者保存**；
2. 函数B在使用寄存器%rbx前，先保存寄存器%rbx的值；在函数B返回之前，先恢复寄存器%rbx原来存储的内容，然后返回，这种策略被称之为**被调用者保存**。



* **被调用者保存寄存器**：`%rbx, %rbp, %r12 ~ %r15`
  
  * 当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时（Q结束时）与Q被调用时（Q开始时）是一样的——要么就是根本不改变它，要么是先存起来（压栈），调用完以后再还回去（逐个弹栈）。**保存它们是被调用者的责任**。
    * `%rbp`**帧指针**：可能用来存储栈帧地址：被调用者开始时的栈顶指针位置
  
  
  
* **调用者保存寄存器**：`%rax, %rcx, %rdi, %rsi, %r8, %r9, %r10, %r11`（`%rax, %rcx`和六个参数）

  * 过程P调用过程Q时，Q可以随便使用这些寄存器。因为P调用Q前，必须先保存这些数据，而在P返回后再将这些数据恢复。**保存它们是调用者的责任**。

    

* `%rsp`：存储栈顶地址

<img src=".\Images\06-Register Saving Conventions.png" style="zoom: 50%;" />



## 递归过程

寄存器和栈的惯例使得 x86-64 的过程能够**递归地调用它们自身**。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储空间。

<img src=".\Images\06-Recursive Function.png" style="zoom: 50%;" />