# Machine-Level Programming V Advanced



## 联合体

* 允许以多种类型来引用一个对象，用不同的字段来引用相同的内存块

  例如：

  ```c
  union u1
  {
      char c;
      int i[2];
      double v;
  };
  sizeof(u1) = 8;
  ```

  对于类型`u1*`的指针`p`，`p -> c`、`p -> i[0]`、`p -> v`引用的都是数据结构的起始位置。

  * 分配的内存大小取决于占用内存最大的字段，同一时间只能使用一个字段

* 绕过了 C 语言类型系统提供的安全措施，可能引起错误



应用：事先知道对一个数据结构中两个不同字段的使用是互斥的，使用联合可减少分配空间的总量

  * 合理使用以减少给代码带来的麻烦
  * 例：用来访问不同类型的位模式

  ```c
  unsigned long double2bits (double d)
  {
      union
      {
          double d;
          unsigned long u;
      } temp;
      temp.d = d;
      return temp.u;
  }
  ```

* **字节顺序很重要**：注意大小端的区别——在大小端机器之间传递数据时，会出大问题



复合数据类型总结：

1. 数组：
   * 内存中连续占用
   * 按照单个元素自身的要求进行数据对齐
   * 指针指向第一个元素
   * 无边界检查
2. 结构体
   * 以声明顺序进行字节分配
   * 为了数据对齐，中部和尾部都有可能分配额外空间
3. 联合体
   * 覆盖型的声明
   * 绕过类型体系的检查





## 内存布局

x86-64 Linux 系统的内存布局：

* Stack
  * 运行时栈，最大8MB，如局部变量
  * `%rsp`记录栈顶地址，向下生长
* Heap
  * 需要时动态分配内存（`malloc()`，`calloc()`，`new()`）
  * 向上生长
* Data
  * 静态分配的数据，如全局变量、静态变量、常量字符串
* Text / Shared Libraries
  * 可执行的机器程序，只读
  * Text 一般从4M开始：`#define NULL 0`
  * $2^{48}$ 以上的地址：保留系统内核中的代码和数据

代码分析：内存占用、爆内存时的分析

随机化：代码安全考虑





## 缓冲区溢出

详情见AttackLab

常见产生原因：输入字符串时未检查其长度，导致输入的内容影响到正常的栈帧，进而影响（控制）程序。

1. **缓冲区溢出攻击**：覆盖原先的返回地址，使函数执行`ret`时跳转到其他的位置；
2. **代码注入攻击**：将要注入的机器码在输入时写入栈帧中，利用缓冲区溢出漏洞，跳转到自己的代码
3. **返回导向编程**（ROP）：从已有的库或者可执行文件中提取指令片段，构成恶意代码
   * 对“Gadget Code”的利用

应对方案：

1. **栈随机化**：使栈的位置在程序每次运行时都有变化，无法产生指向攻击字符串的指针，从而防止一定程度的攻击。
   * ASLR：地址空间布局随机化技术：每次运行时，程序的不同部分（程序代码、库代码、栈、全局变量、堆数据）都会加载到程序的不同位置，Linux系统中的标准行为
2. **栈破坏检测**：在局部缓冲区和栈状态之间放一个随机的“金丝雀值”，函数返回前检查其值，若被改变，则程序异常终止。
3. **限制可执行代码区域**
   * 防不了ROP

